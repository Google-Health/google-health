"""Beam wrappers for DICOMweb API helpers in `dicomweb.py`."""

import dataclasses
from typing import Iterable, Optional, Tuple

from absl import logging
import apache_beam as beam
from apache_beam import pvalue
from google.auth.transport import requests

from gcp import auth
from gcp import dicomweb

# CHC DICOMweb API search query limits:
# https://cloud.google.com/healthcare-api/docs/dicom#search_parameters
_STUDY_SEARCH_QUERY_LIMIT = 5000
_SERIES_SEARCH_QUERY_LIMIT = 5000


def to_csv_row(values: Iterable[str]) -> str:
  """Converts sequence of strings to a comma-separated, quoted CSV row."""
  return ','.join(f'"{value}"' for value in values)


@dataclasses.dataclass(frozen=True)
class ChcDicomStore:
  """URI components to identify a CHC DICOM Store.

  Attributes:
    project_id: The GCP Project name that hosts the DICOM Store.
    location: The DICOM Dataset location (region) which contains the DICOM
      Store.
    dataset_id: The name of the DICOM Dataset which contains the DICOM Store.
    dicom_store_id: The name of the CHC DICOM Store.
  """

  project_id: str
  location: str
  dataset_id: str
  dicom_store_id: str


@dataclasses.dataclass(frozen=True)
class SeriesScopeMetadata:
  """DICOM metadata shared at the scope of a Series Instance UID.

  Attributes:
    study_instance_uid: The DICOM Study Instance UID Attribute (0020, 000D)
      value.
    series_instance_uid: The DICOM Series Instance UID Attribute (0020, 000E)
      value.
  """

  study_instance_uid: str
  series_instance_uid: str

  @property
  def key(self) -> str:
    """Generates a key to make key-value pairs from an instance."""
    return f'{self.study_instance_uid}/{self.series_instance_uid}'


@dataclasses.dataclass(frozen=True)
class SeriesScopeDICOMs:
  """DICOM bytes and select metadata at the Series Instance UID scope.

  Attributes:
    metadata: DICOM metadata shared by all contained DICOMs at the Series
      Instance UID (0020, 000E) scope.
    dicoms: Sequence of DICOM bytes, each sharing the same Study Instance UID
      Attribute (0020, 000D) value and Series Instance UID Attribute (0020,
      000E) value.
  """

  metadata: SeriesScopeMetadata
  dicoms: Tuple[bytes, ...]

  @property
  def key(self) -> str:
    """Generates a key to make key-value pairs from an instance."""
    return self.metadata.key


class BaseDoFnWithAuthorizedSessionForChc(beam.DoFn):
  """Beam DoFn base class that manages Session and Credentials for CHC APIs.

  Before bundle processing begins, it generates a fresh set of Google Auth
  Credentials and an Authorized Session with the Cloud Healthcare API Scope.
  Since neither Credentials nor Sessions are natively serializable in Beam, they
  are initialized in each worker independently. Since the Credentials are
  controlled by command line flags, which do get serialized, they are available
  to the workers for Credentials initialization.

  Initializing Credentials every time a new bundle is processed may be overkill,
  but since some Credentials have timebound validity, managing their freshness
  tends to complicate DoFn implementations. For most cases, re-initializing
  Credentials before processing a new bundle ought to suffice.
  """

  @property
  def session(self) -> Optional[requests.AuthorizedSession]:
    """Returns an initialized Session at CHC API Scope.

    Unless the Session is initialized by at least one call to `start_bundle()`,
    it returns `None`.

    Returns:
      An initialized Session, if available.
    """
    try:
      return self._session
    except AttributeError:
      return None

  def start_bundle(self):
    """Initializes an Authorized Session for the CHC API Scope."""
    credentials = auth.create_gcp_credentials()
    self._session = dicomweb.create_authorized_session(credentials)


class QueryStudyInstanceUidsFn(BaseDoFnWithAuthorizedSessionForChc):
  """Beam DoFn to query all Study Instance UIDs within a CHC DICOM Store.

  All Study Instance UIDs are generated by one Beam worker. Study Instance
  UIDs (0020,000D) are internally retrieved lazily in batches of up to 5000
  values, but emitted one-by-one in the `process()` method.

  This also means that if retrieval takes sufficiently long, some Credentials
  may expire. Other than explicit Credentials and Session management, a
  workaround could be to force the generation of all UIDs before feeding them to
  the downstream Beam pipeline components by adding a Shuffle operation to the
  output of this class.
  """

  def __init__(self, dicom_store: ChcDicomStore) -> None:
    """Initializes an instance.

    Args:
      dicom_store: The CHC DICOM Store URI components.
    """
    super().__init__()
    self._dicom_store = dicom_store

  def process(self, _) -> Iterable[str]:
    """Generates all Study Instance UIDs within the CHC DICOM Store."""
    assert self.session is not None
    return dicomweb.search_study_instance_uids(
        self._dicom_store.project_id,
        self._dicom_store.location,
        self._dicom_store.dataset_id,
        self._dicom_store.dicom_store_id,
        self.session,
        limit=_STUDY_SEARCH_QUERY_LIMIT,
    )


class QuerySeriesInstanceUidsFn(BaseDoFnWithAuthorizedSessionForChc):
  """Beam DoFn to query all Series Instance UIDs within a Study Instance UID."""

  def __init__(self, dicom_store: ChcDicomStore) -> None:
    """Initializes an instance.

    Args:
      dicom_store: The CHC DICOM Store URI components.
    """
    super().__init__()
    self._dicom_store = dicom_store

  def process(self, study_instance_uid: str) -> Iterable[SeriesScopeMetadata]:
    """Generates all Series Instance UIDs within the input Study Instance UID.

    Args:
      study_instance_uid: The DICOM Study Instance UID (0020, 000D) Attribute
        value to scope the query within.

    Yields:
      All Series Instance UID (0020, 000E) Attribute value within all DICOMs
      matching the Study Instance UID Attribute value of `study_instance_uid`.
    """
    assert self.session is not None
    for series_instance_uid in dicomweb.search_series_instance_uids(
        self._dicom_store.project_id,
        self._dicom_store.location,
        self._dicom_store.dataset_id,
        self._dicom_store.dicom_store_id,
        self.session,
        study_instance_uid,
        limit=_SERIES_SEARCH_QUERY_LIMIT,
    ):
      yield SeriesScopeMetadata(study_instance_uid, series_instance_uid)


class DownloadMultipartDicomSeriesFn(BaseDoFnWithAuthorizedSessionForChc):
  """Beam DoFn to download all DICOMs with the same Series and Study UIDs.

  The DICOMs are downloaded in one multi-part GET request for efficiency. It
  reduces the network and DICOM Store latency involved in otherwise issuing
  multiple GET requests, as well as the CHC API Quota usage.

  The downloaded DICOM bytes and information about any errors during download
  are routed to separate, tagged PCollections.
  """

  ERROR_OUTPUT_TAG = 'errors'

  def __init__(self, dicom_store: ChcDicomStore) -> None:
    """Initializes an instance.

    Args:
      dicom_store: The CHC DICOM Store URI components.
    """
    super().__init__()
    self._dicom_store = dicom_store

  def process(self, series_scope_metadata: SeriesScopeMetadata):
    """Emits a DICOM collection sharing the same Study and Series UIDs.

    In case of errors during download, the error string is output to a Beam
    TaggedOutput with tag "errors", in the form of a CSV row with entries:
    "<Study Instance UID>","<Series Instance UID>","<error-string>"

    Args:
      series_scope_metadata: The Study Instance UID (0020, 000D) and Series
        Instance UID (0020, 000E) Attribute values for the DICOMs to download.

    Yields:
      A single collection of DICOMs sharing the same Study and Series Instance
      UID if download was successful. A CSV row to a TaggedOutput, otherwise.
    """
    assert self.session is not None
    try:
      yield SeriesScopeDICOMs(
          series_scope_metadata,
          tuple(
              dicomweb.download_multipart_dicom_series(
                  self._dicom_store.project_id,
                  self._dicom_store.location,
                  self._dicom_store.dataset_id,
                  self._dicom_store.dicom_store_id,
                  self.session,
                  series_scope_metadata.study_instance_uid,
                  series_scope_metadata.series_instance_uid,
              )
          ),
      )
    except Exception as e:  # pylint: disable=broad-exception-caught
      logging.error('Error downloading %r', series_scope_metadata.key)
      yield pvalue.TaggedOutput(
          self.ERROR_OUTPUT_TAG,
          to_csv_row((
              series_scope_metadata.study_instance_uid,
              series_scope_metadata.series_instance_uid,
              *e.args,
          )),
      )
